#!/usr/bin/env bash
# gather_missing_context.sh - Answer "if we knew X" questions between iterations
#
# When models output "if we knew X, confidence would be higher", this script
# finds X and provides it to the next iteration.
#
# Supports common question patterns:
# - "how X handles Y" → grep for Y handler
# - "where X is defined" → grep for definition
# - "what calls X" → grep for usages
# - "failing test" → run tests and capture output
# - "state machine" → grep for state/reducer patterns
# - "worker message" → grep for postMessage patterns

set -euo pipefail

QUESTIONS_FILE="${1:-}"
OUTPUT_FILE="${2:-/tmp/missing_context_answers.md}"

if [[ -z "$QUESTIONS_FILE" ]]; then
  echo "Usage: $0 <questions_file> [output_file]"
  echo "  questions_file: JSON file with questions array"
  echo '  Format: [{"question": "...", "model": "...", "why": "..."}]'
  exit 1
fi

if [[ ! -f "$QUESTIONS_FILE" ]]; then
  echo "Error: Questions file not found: $QUESTIONS_FILE" >&2
  exit 1
fi

# Initialize output
cat > "$OUTPUT_FILE" << 'EOF'
# Missing Context Answers

This document contains answers to questions raised by previous iteration models.
Generated by gather_missing_context.sh

---

EOF

# Search for how something handles something
search_handler() {
  local subject="$1"
  local target="$2"

  echo "**Searching for:** how $subject handles $target"
  echo ""

  # Look for handler patterns
  local results
  results=$(rg -n -C 3 "$target" --glob '*.{ts,tsx,js,jsx}' 2>/dev/null | head -50 || true)

  if [[ -n "$results" ]]; then
    echo '```'
    echo "$results"
    echo '```'
  else
    echo "*No direct handler found for '$target'*"
  fi
}

# Search for where something is defined
search_definition() {
  local name="$1"

  echo "**Searching for definition of:** $name"
  echo ""

  # Look for various definition patterns
  local patterns=(
    "class $name"
    "function $name"
    "const $name"
    "let $name"
    "var $name"
    "export.*$name"
    "interface $name"
    "type $name"
    "def $name"
  )

  for pattern in "${patterns[@]}"; do
    local results
    results=$(rg -n "$pattern" --glob '*.{ts,tsx,js,jsx,py}' 2>/dev/null | head -10 || true)
    if [[ -n "$results" ]]; then
      echo "Found with pattern: \`$pattern\`"
      echo '```'
      echo "$results"
      echo '```'
      return
    fi
  done

  echo "*No definition found for '$name'*"
}

# Search for what calls something
search_usages() {
  local name="$1"

  echo "**Searching for usages of:** $name"
  echo ""

  # Look for function calls
  local results
  results=$(rg -n "${name}\(" --glob '*.{ts,tsx,js,jsx}' 2>/dev/null | head -30 || true)

  if [[ -n "$results" ]]; then
    echo '```'
    echo "$results"
    echo '```'
  else
    echo "*No usages found for '$name'*"
  fi
}

# Run tests and capture output
run_tests() {
  local test_pattern="${1:-}"

  echo "**Running tests**"
  echo ""

  local cmd=""
  # Detect test runner
  if [[ -f "package.json" ]]; then
    if grep -q '"vitest"' package.json 2>/dev/null; then
      cmd="npx vitest run --reporter=verbose"
    elif grep -q '"jest"' package.json 2>/dev/null; then
      cmd="npx jest --verbose"
    elif grep -q '"test"' package.json 2>/dev/null; then
      cmd="npm test"
    fi
  elif [[ -f "pytest.ini" ]] || [[ -f "pyproject.toml" ]]; then
    cmd="python -m pytest -v"
  elif [[ -f "Cargo.toml" ]]; then
    cmd="cargo test"
  fi

  if [[ -n "$cmd" ]]; then
    if [[ -n "$test_pattern" ]]; then
      cmd="$cmd $test_pattern"
    fi
    echo "Running: \`$cmd\`"
    echo ""
    echo '```'
    # Use gtimeout on macOS, timeout on Linux
    local timeout_cmd="timeout"
    command -v gtimeout &>/dev/null && timeout_cmd="gtimeout"
    command -v "$timeout_cmd" &>/dev/null || timeout_cmd=""

    if [[ -n "$timeout_cmd" ]]; then
      $timeout_cmd 120 bash -c "$cmd" 2>&1 | tail -100 || echo "Tests timed out or failed"
    else
      bash -c "$cmd" 2>&1 | tail -100 || echo "Tests failed (no timeout available)"
    fi
    echo '```'
  else
    echo "*Could not detect test runner*"
  fi
}

# Search for state machine patterns
search_state_machine() {
  echo "**Searching for state machine patterns**"
  echo ""

  local patterns=("state" "reducer" "action" "dispatch" "transition" "setState")

  for pattern in "${patterns[@]}"; do
    local results
    results=$(rg -n -C 1 "$pattern" --glob '*.{ts,tsx,js,jsx}' 2>/dev/null | head -20 || true)
    if [[ -n "$results" ]]; then
      echo "Pattern: \`$pattern\`"
      echo '```'
      echo "$results"
      echo '```'
      echo ""
    fi
  done
}

# Search for worker message patterns
search_worker_messages() {
  echo "**Searching for worker message patterns**"
  echo ""

  local patterns=("postMessage" "onmessage" "addEventListener.*message" "worker.on")

  for pattern in "${patterns[@]}"; do
    local results
    results=$(rg -n -C 2 "$pattern" --glob '*.{ts,tsx,js,jsx}' 2>/dev/null | head -30 || true)
    if [[ -n "$results" ]]; then
      echo "Pattern: \`$pattern\`"
      echo '```'
      echo "$results"
      echo '```'
      echo ""
    fi
  done
}

# Read a specific file and extract relevant portions
read_file_context() {
  local file="$1"
  local line="${2:-}"

  echo "**Reading:** $file"
  echo ""

  if [[ -f "$file" ]]; then
    local ext="${file##*.}"
    if [[ -n "$line" ]]; then
      # Show context around specific line
      local start=$((line - 10))
      [[ $start -lt 1 ]] && start=1
      local end=$((line + 10))
      echo "Lines $start-$end:"
      echo '```'"$ext"
      sed -n "${start},${end}p" "$file"
      echo ""
      echo '```'
    else
      # Show full file if small, or head/tail if large
      local line_count
      line_count=$(wc -l < "$file" | tr -d ' ')
      if [[ $line_count -lt 200 ]]; then
        echo '```'"$ext"
        cat "$file"
        echo ""
        echo '```'
      else
        echo "File has $line_count lines, showing head and tail:"
        echo '```'"$ext"
        head -50 "$file"
        echo "... ($(( line_count - 100 )) lines omitted) ..."
        tail -50 "$file"
        echo ""
        echo '```'
      fi
    fi
  else
    echo "*File not found: $file*"
  fi
}

# Parse question and determine search strategy
answer_question() {
  local question="$1"
  local model="$2"
  local why="$3"

  echo "## Question from $model"
  echo ""
  echo "> $question"
  echo ""
  echo "**Why needed:** $why"
  echo ""

  # Normalize question to lowercase for pattern matching
  local q_lower
  q_lower=$(echo "$question" | tr '[:upper:]' '[:lower:]')

  # Determine search strategy based on question pattern
  if [[ "$q_lower" =~ "how".+"handles" ]]; then
    # Extract subject and target from "how X handles Y"
    # Use lowercase version for extraction to avoid BSD sed compatibility issues
    local subject target
    subject=$(echo "$q_lower" | sed -n 's/.*how \([^ ]*\) handles.*/\1/p')
    target=$(echo "$q_lower" | sed -n 's/.*handles \(.*\)[?]*/\1/p' | sed 's/[[:space:]]*$//')
    if [[ -n "$subject" ]] && [[ -n "$target" ]]; then
      search_handler "$subject" "$target"
    else
      echo "*Could not parse 'how X handles Y' pattern from question*"
    fi

  elif [[ "$q_lower" =~ "where".+"defined" ]] || [[ "$q_lower" =~ "definition of" ]]; then
    # Extract what to find - look for CamelCase identifiers in original question
    local name
    name=$(echo "$question" | grep -oE '[A-Z][a-zA-Z0-9]+' | head -1 || true)
    if [[ -n "$name" ]]; then
      search_definition "$name"
    else
      echo "*Could not extract identifier name from question*"
    fi

  elif [[ "$q_lower" =~ "what calls" ]] || [[ "$q_lower" =~ "who calls" ]] || [[ "$q_lower" =~ "usages of" ]]; then
    local name
    name=$(echo "$question" | grep -oE '[A-Z][a-zA-Z0-9]+' | head -1 || true)
    if [[ -n "$name" ]]; then
      search_usages "$name"
    else
      echo "*Could not extract function name from question*"
    fi

  elif [[ "$q_lower" =~ "failing test" ]] || [[ "$q_lower" =~ "test output" ]] || [[ "$q_lower" =~ "test results" ]]; then
    run_tests ""

  elif [[ "$q_lower" =~ "state" ]] && [[ "$q_lower" =~ "machine" ]]; then
    search_state_machine

  elif [[ "$q_lower" =~ "worker" ]] && [[ "$q_lower" =~ "message" ]]; then
    search_worker_messages

  elif [[ "$q_lower" =~ "content" ]] || [[ "$q_lower" =~ "source" ]] || [[ "$q_lower" =~ "code in" ]]; then
    # Try to extract file path from question
    local file
    file=$(echo "$question" | grep -oE '[a-zA-Z0-9_/.-]+\.(ts|tsx|js|jsx|py|rs|go)' | head -1 || true)
    if [[ -n "$file" ]]; then
      read_file_context "$file"
    else
      echo "*Could not extract file path from question*"
    fi

  else
    # Generic search - try to find key terms
    echo "**Generic search for key terms in question**"
    echo ""

    # Extract potential identifiers (CamelCase or snake_case words)
    local terms
    terms=$(echo "$question" | grep -oE '[A-Z][a-zA-Z0-9]+|[a-z]+_[a-z_]+' | head -3 || true)

    for term in $terms; do
      echo "### Searching for: $term"
      local results
      results=$(rg -n -C 1 "$term" --glob '*.{ts,tsx,js,jsx}' 2>/dev/null | head -20 || true)
      if [[ -n "$results" ]]; then
        echo '```'
        echo "$results"
        echo '```'
      else
        echo "*No results for '$term'*"
      fi
      echo ""
    done
  fi

  echo ""
  echo "---"
  echo ""
}

# Process questions from JSON file
process_questions() {
  local questions_file="$1"

  # Check if jq is available
  if ! command -v jq &> /dev/null; then
    echo "Error: jq is required but not installed" >&2
    exit 1
  fi

  # Read and process each question
  local count
  count=$(jq 'length' "$questions_file" 2>/dev/null) || {
    echo "Error: Failed to parse JSON file: $questions_file" >&2
    exit 1
  }

  if [[ -z "$count" ]] || [[ "$count" == "null" ]]; then
    echo "Error: Invalid JSON structure in $questions_file" >&2
    exit 1
  fi

  echo "Processing $count questions..."
  echo ""

  for i in $(seq 0 $((count - 1))); do
    local question model why
    question=$(jq -r ".[$i].question // .[$i]" "$questions_file")
    model=$(jq -r ".[$i].model // \"unknown\"" "$questions_file")
    why=$(jq -r ".[$i].why // .[$i].why_they_need_it // \"not specified\"" "$questions_file")

    answer_question "$question" "$model" "$why" >> "$OUTPUT_FILE"
  done
}

# Also support plain text questions (one per line)
process_text_questions() {
  local questions_file="$1"

  echo "Processing text questions..."
  echo ""

  while IFS= read -r question || [[ -n "$question" ]]; do
    # Skip empty lines and comments
    [[ -z "$question" ]] && continue
    [[ "$question" =~ ^# ]] && continue

    answer_question "$question" "previous iteration" "improve confidence" >> "$OUTPUT_FILE"
  done < "$questions_file"
}

# Main
if [[ "$QUESTIONS_FILE" == *.json ]]; then
  process_questions "$QUESTIONS_FILE"
else
  process_text_questions "$QUESTIONS_FILE"
fi

echo "Answers written to: $OUTPUT_FILE"
echo ""

# Print summary
echo "## Summary" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"
echo "Generated: $(date '+%Y-%m-%dT%H:%M:%S%z')" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"
echo "Use this context in the next iteration to improve confidence scores." >> "$OUTPUT_FILE"

# Output the file path
echo "$OUTPUT_FILE"
