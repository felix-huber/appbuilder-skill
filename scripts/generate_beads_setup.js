#!/usr/bin/env node
/**
 * Generate beads_rust (br) setup script from task-graph.json
 * 
 * This transforms the compiled task graph into self-documenting beads
 * following the Doodlestein principle: "so detailed we never need the original"
 * 
 * Usage:
 *   node scripts/generate_beads_setup.js [--out artifacts/04-beads-setup.sh]
 * 
 * Output: A bash script that creates all beads with rich descriptions
 */

const fs = require('fs');
const path = require('path');

const TASK_GRAPH_PATH = 'artifacts/04-task-graph.json';
const DEFAULT_OUTPUT = 'artifacts/04-beads-setup.sh';

function die(msg) {
  console.error('Error:', msg);
  process.exit(1);
}

function arg(name) {
  const idx = process.argv.indexOf(name);
  if (idx === -1) return null;
  return process.argv[idx + 1] || null;
}

function escapeForBashDoubleQuotes(str) {
  // Escape for usage inside bash double quotes ("...").
  // This avoids breaking the generated script when subjects/tags contain
  // characters like ", $, `, or backslashes.
  return String(str)
    .replace(/\\/g, '\\\\')
    .replace(/"/g, '\\"')
    .replace(/\$/g, '\\$')
    .replace(/`/g, '\\`');
}

function escapeForDescription(str) {
  // Escape for multi-line bash heredoc-style strings
  return str
    .replace(/\\/g, '\\\\')
    .replace(/"/g, '\\"')
    .replace(/\$/g, '\\$')
    .replace(/`/g, '\\`');
}

function generateRichDescription(task, allTasks) {
  const parts = [];
  
  // Context section
  parts.push('CONTEXT:');
  if (task.source === 'oracle') {
    parts.push(`This task addresses an Oracle-identified issue (${task.severity} severity).`);
  } else if (task.sprint) {
    parts.push(`Part of Sprint ${task.sprint}. ${task.sprintGoal || ''}`);
  }
  if (task.tags && task.tags.length > 0) {
    parts.push(`Tags: ${task.tags.join(', ')}`);
  }
  parts.push('');
  
  // Original description
  if (task.description) {
    parts.push('DETAILS:');
    parts.push(task.description);
    parts.push('');
  }
  
  // Deliverable
  if (task.deliverable) {
    parts.push('DELIVERABLE:');
    parts.push(task.deliverable);
    parts.push('');
  }
  
  // Allowed paths
  if (task.allowedPaths && task.allowedPaths.length > 0) {
    parts.push('ALLOWED PATHS:');
    parts.push(task.allowedPaths.join(', '));
    parts.push('');
  }
  
  // Verification
  if (task.verification && task.verification.length > 0) {
    parts.push('VERIFICATION:');
    task.verification.forEach(v => parts.push(`- ${v}`));
    parts.push('');
  }
  
  // Dependencies context
  if (task.blockedBy && task.blockedBy.length > 0) {
    parts.push('DEPENDENCIES:');
    task.blockedBy.forEach(depId => {
      const dep = allTasks.find(t => t.id === depId);
      if (dep) {
        parts.push(`- ${depId}: ${dep.subject}`);
      } else {
        parts.push(`- ${depId}`);
      }
    });
    parts.push('');
  }
  
  // Setup instructions
  if (task.setup) {
    parts.push('SETUP:');
    parts.push(task.setup);
    parts.push('');
  }
  
  return parts.join('\n').trim();
}

function priorityFromSeverity(severity) {
  const map = {
    'blocker': 0,
    'critical': 0,
    'major': 1,
    'minor': 2,
    'nit': 3
  };
  return map[severity] || 2;
}

function typeFromTags(tags) {
  if (!tags || tags.length === 0) return 'task';
  const t = tags.map(tag => tag.toLowerCase());
  if (t.includes('bug') || t.includes('fix')) return 'bug';
  if (t.includes('feature')) return 'feature';
  if (t.includes('chore') || t.includes('cleanup')) return 'chore';
  return 'task';
}

function generateBeadsScript(taskGraph) {
  const lines = [];
  const tasks = taskGraph.tasks || [];
  
  lines.push('#!/usr/bin/env bash');
  lines.push('# Generated by Oracle Swarm - generate_beads_setup.js');
  lines.push('# Run this script to create beads from the task graph');
  lines.push('#');
  lines.push('# Prerequisites:');
  lines.push('#   cargo install --git https://github.com/Dicklesworthstone/beads_rust.git');
  lines.push('#   br init');
  lines.push('#');
  lines.push('# After running, iterate on beads with:');
  lines.push('#   br list  # Review all beads');
  lines.push('#   br ready # See actionable tasks');
  lines.push('#');
  lines.push('# IMPORTANT: Run the beads review prompt 6-9 times before implementation!');
  lines.push('');
  lines.push('set -euo pipefail');
  lines.push('');
  lines.push('# Check br is installed');
  lines.push('if ! command -v br &> /dev/null; then');
  lines.push('  echo "Error: br (beads_rust) not found"');
  lines.push('  echo "Install with: cargo install --git https://github.com/Dicklesworthstone/beads_rust.git"');
  lines.push('  exit 1');
  lines.push('fi');
  lines.push('');
  lines.push('# Check jq is installed (required for --json parsing)');
  lines.push('if ! command -v jq &> /dev/null; then');
  lines.push('  echo "Error: jq not found"');
  lines.push('  echo "Install with: brew install jq (macOS) or apt install jq (Linux)"');
  lines.push('  exit 1');
  lines.push('fi');
  lines.push('');
  lines.push('# Check beads is initialized');
  lines.push('if [[ ! -d ".beads" ]]; then');
  lines.push('  echo "Initializing beads..."');
  lines.push('  br init');
  lines.push('fi');
  lines.push('');
  lines.push('echo "Creating beads from task graph..."');
  lines.push('echo ""');
  lines.push('');
  
  // Group tasks by sprint
  const sprints = new Map();
  const noSprint = [];
  
  for (const task of tasks) {
    if (task.sprint) {
      if (!sprints.has(task.sprint)) {
        sprints.set(task.sprint, []);
      }
      sprints.get(task.sprint).push(task);
    } else {
      noSprint.push(task);
    }
  }
  
  // Variable to track ID mappings (task.id -> br variable name)
  const idVarMap = new Map();
  
  // Create sprint epics first
  if (sprints.size > 0) {
    const sortedSprints = Array.from(sprints.keys()).sort((a, b) => a - b);
    
    for (const sprintNum of sortedSprints) {
      const sprintTasks = sprints.get(sprintNum);
      const firstTask = sprintTasks[0];
      const sprintGoal = firstTask.sprintGoal || `Sprint ${sprintNum}`;
      
      const epicVar = `S${sprintNum}`;
      
      lines.push(`# ═══════════════════════════════════════════════════════════════`);
      lines.push(`# Sprint ${sprintNum}: ${sprintGoal}`);
      lines.push(`# ═══════════════════════════════════════════════════════════════`);
      lines.push(`echo "Creating Sprint ${sprintNum}..."`);
      lines.push(`${epicVar}=$(br create "Sprint ${sprintNum}: ${escapeForBashDoubleQuotes(sprintGoal)}" -t epic -p 1 --json | jq -r '.id')`);
      lines.push(`echo "  Epic: $${epicVar}"`);
      lines.push('');
      
      // Create tasks for this sprint
      for (const task of sprintTasks) {
        const taskVar = `T_${task.id.replace(/[^a-zA-Z0-9]/g, '_')}`;
        idVarMap.set(task.id, taskVar);
        
        const richDesc = generateRichDescription(task, tasks);
        const priority = task.priority || priorityFromSeverity(task.severity) || 2;
        const type = typeFromTags(task.tags);
        
        lines.push(`# Task: ${task.id}`);
        lines.push(`${taskVar}=$(br create "${escapeForBashDoubleQuotes(task.subject)}" \\`);
        lines.push(`  -t ${type} \\`);
        lines.push(`  -p ${priority} \\`);
        lines.push(`  --parent "$${epicVar}" \\`);
        lines.push(`  --description "${escapeForDescription(richDesc)}" \\`);
        lines.push(`  --json | jq -r '.id')`);
        lines.push(`echo "  Task: $${taskVar} - ${escapeForBashDoubleQuotes(task.subject.substring(0, 50))}..."`);
        
        // Add labels
        if (task.tags && task.tags.length > 0) {
          const labelArgs = task.tags
            .map(t => `"${escapeForBashDoubleQuotes(String(t))}"`)
            .join(' ');
          lines.push(`br label add "$${taskVar}" ${labelArgs} 2>/dev/null || true`);
        }
        
        lines.push('');
      }
    }
  }
  
  // Create non-sprint tasks (oracle issues, etc.)
  if (noSprint.length > 0) {
    lines.push('# ═══════════════════════════════════════════════════════════════');
    lines.push('# Additional Tasks (Oracle Issues, etc.)');
    lines.push('# ═══════════════════════════════════════════════════════════════');
    lines.push('echo "Creating additional tasks..."');
    lines.push('');
    
    for (const task of noSprint) {
      const taskVar = `T_${task.id.replace(/[^a-zA-Z0-9]/g, '_')}`;
      idVarMap.set(task.id, taskVar);
      
      const richDesc = generateRichDescription(task, tasks);
      const priority = task.priority || priorityFromSeverity(task.severity) || 2;
      const type = task.source === 'oracle' ? 'bug' : typeFromTags(task.tags);
      
      lines.push(`# Task: ${task.id} (${task.source || 'manual'})`);
      lines.push(`${taskVar}=$(br create "${escapeForBashDoubleQuotes(task.subject)}" \\`);
      lines.push(`  -t ${type} \\`);
      lines.push(`  -p ${priority} \\`);
      lines.push(`  --description "${escapeForDescription(richDesc)}" \\`);
      lines.push(`  --json | jq -r '.id')`);
      lines.push(`echo "  Task: $${taskVar}"`);
      
      if (task.tags && task.tags.length > 0) {
        const labelArgs = task.tags
          .map(t => `"${escapeForBashDoubleQuotes(String(t))}"`)
          .join(' ');
        lines.push(`br label add "$${taskVar}" ${labelArgs} 2>/dev/null || true`);
      }
      
      lines.push('');
    }
  }
  
  // Add dependencies
  lines.push('# ═══════════════════════════════════════════════════════════════');
  lines.push('# Dependencies');
  lines.push('# ═══════════════════════════════════════════════════════════════');
  lines.push('echo ""');
  lines.push('echo "Setting up dependencies..."');
  lines.push('');
  
  let depCount = 0;
  for (const task of tasks) {
    if (!task.blockedBy || task.blockedBy.length === 0) continue;
    
    const taskVar = idVarMap.get(task.id);
    if (!taskVar) continue;
    
    for (const depId of task.blockedBy) {
      const depVar = idVarMap.get(depId);
      if (depVar) {
        lines.push(`br dep add "$${taskVar}" "$${depVar}" 2>/dev/null || echo "  Warning: Could not add dep ${task.id} -> ${depId}"`);
        depCount++;
      } else {
        lines.push(`# Warning: Dependency ${depId} not found for ${task.id}`);
      }
    }
  }
  
  if (depCount === 0) {
    lines.push('echo "  No dependencies to set up"');
  }
  
  // Summary
  lines.push('');
  lines.push('# ═══════════════════════════════════════════════════════════════');
  lines.push('# Summary');
  lines.push('# ═══════════════════════════════════════════════════════════════');
  lines.push('echo ""');
  lines.push('echo "════════════════════════════════════════════════════════════"');
  lines.push('echo "  BEADS CREATED SUCCESSFULLY"');
  lines.push('echo "════════════════════════════════════════════════════════════"');
  lines.push('TOTAL=$(br list --json 2>/dev/null | jq length)');
  lines.push('READY=$(br ready --json 2>/dev/null | jq length)');
  lines.push('echo ""');
  lines.push('echo "  Total beads: $TOTAL"');
  lines.push('echo "  Ready to start: $READY"');
  lines.push('echo ""');
  lines.push('echo "NEXT STEPS:"');
  lines.push('echo "  1. Review beads: br list"');
  lines.push('echo "  2. Run beads review prompt 6-9 times (see skills/phase-transitions/SKILL.md)"');
  lines.push('echo "  3. Sync to git: br sync --flush-only && git add .beads/ && git commit"');
  lines.push('echo "  4. Start execution: ./scripts/ralph.sh --beads 50"');
  lines.push('echo ""');
  lines.push('');
  lines.push('# Export for git');
  lines.push('br sync --flush-only');
  lines.push('echo "Beads exported to .beads/issues.jsonl"');
  
  return lines.join('\n');
}

// Main
function main() {
  const outputPath = arg('--out') || DEFAULT_OUTPUT;

  if (!fs.existsSync(TASK_GRAPH_PATH)) {
    die(`Task graph not found at ${TASK_GRAPH_PATH}. Run /artifact-tasks first.`);
  }

  const taskGraph = JSON.parse(fs.readFileSync(TASK_GRAPH_PATH, 'utf8'));

  if (!taskGraph.tasks || taskGraph.tasks.length === 0) {
    die('Task graph has no tasks');
  }

  const script = generateBeadsScript(taskGraph);

  // Ensure output directory exists
  const outDir = path.dirname(outputPath);
  if (!fs.existsSync(outDir)) {
    fs.mkdirSync(outDir, { recursive: true });
  }

  fs.writeFileSync(outputPath, script);
  fs.chmodSync(outputPath, 0o755);

  console.log(`Generated beads setup script: ${outputPath}`);
  console.log(`  Tasks: ${taskGraph.tasks.length}`);
  console.log(`  Sprints: ${new Set(taskGraph.tasks.filter(t => t.sprint).map(t => t.sprint)).size}`);
  console.log('');
  console.log('Run with: bash ' + outputPath);
}

try {
  main();
} catch (err) {
  console.error('Error:', err.message);
  if (process.env.DEBUG) console.error(err.stack);
  process.exit(1);
}
