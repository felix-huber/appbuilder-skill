# /artifact-tasks — Compile Task Graph + Create Tasks

## Goal
Compile task seeds from plan + Oracle issues into a canonical task graph,
then create tasks in your chosen system (Claude Code tasks, beads_rust, or task-graph.json).

## Prerequisites
- `artifacts/03-plan.md` must exist (with task seeds in sprint format)
- `artifacts/06-oracle/plan/issues.json` must exist (run `/oracle plan` first, iterate until convergence)

---

## ⚠️ CHECK EXISTING STATE FIRST

**Before compiling, check what already exists:**

```bash
# Check if task graph already exists
ls -la artifacts/04-task-graph.json 2>/dev/null
cat artifacts/04-task-graph.json 2>/dev/null | jq '.meta.counts'

# Check plan convergence (prerequisite)
cat artifacts/06-oracle/plan/convergence-history.json 2>/dev/null

# Check if beads already created
ls -la .beads/*.jsonl 2>/dev/null
```

| Situation | Action |
|-----------|--------|
| Plan not converged | → Run `/oracle plan` first |
| No task graph exists | → Compile it (this command) |
| Task graph exists but plan changed | → Recompile |
| Task graph + beads exist | → Skip to `/ralph` |

---

## Inputs
- `artifacts/03-plan.md` — Contains sprint-organized task seeds
- `artifacts/06-oracle/plan/issues.json` — Oracle-identified issues

## Outputs
- `artifacts/04-task-graph.json` — Canonical task graph (always generated)
- Optional: `artifacts/04-beads-setup.sh` — beads_rust commands
- Optional: Claude Code task list (via TaskCreate/TaskUpdate)

## Steps

### 1. Validate prerequisites
```bash
if [ ! -f artifacts/03-plan.md ]; then
  echo "Missing plan. Run /plan first."
  exit 1
fi

if [ ! -f artifacts/06-oracle/plan/issues.json ]; then
  echo "Missing Oracle review. Run /oracle plan first (iterate until convergence!)."
  exit 1
fi
```

### 2. Compile task graph
Run the compiler:
```bash
node scripts/compile_task_graph.js \
  --plan artifacts/03-plan.md \
  --issues artifacts/06-oracle/plan/issues.json \
  --out artifacts/04-task-graph.json
```

### 3. Report compilation results
```bash
cat artifacts/04-task-graph.json | jq '.meta.counts'
```

Expected output:
```json
{
  "seedTasks": 12,
  "issueTasks": 8,
  "total": 20
}
```

### 4. Ask: Which task system?

> Which task management system would you like to use?
>
> **[1] beads_rust (br)** — Recommended for autonomous agent execution
>   - Local-first, git-friendly
>   - Dependency-aware task selection with `br ready`
>   - Works with Ralph's `--beads` mode
>
> **[2] task-graph.json only** — Built-in Oracle Swarm format
>   - No external dependencies
>   - Works with Ralph's default mode
>
> **[3] Claude Code Tasks** — Claude's built-in task system
>   - Integrated with Claude Code
>   - Uses TaskCreate/TaskUpdate tools

### 5a. Generate beads commands (if beads selected)

Create `artifacts/04-beads-setup.sh`:

```bash
#!/usr/bin/env bash
set -euo pipefail

# Generated by Oracle Swarm - /artifact-tasks
# This script creates beads from the compiled task graph
#
# Prerequisites:
#   cargo install --git https://github.com/Dicklesworthstone/beads_rust.git
#   br init

echo "Creating beads from task graph..."

# Sprint 1: Foundation
echo "Sprint 1: Foundation"
S1=$(br create "Sprint 1: Foundation" -t epic -p 1 --json | jq -r '.id')

S1T1=$(br create "Initialize project structure" -t task -p 1 --parent "$S1" \
  --description "Deliverable: package.json, tsconfig.json, vite.config.ts
  
Verification: npm run dev starts without errors

This establishes the project foundation. All other tasks depend on this." --json | jq -r '.id')
br label add "$S1T1" setup core

S1T2=$(br create "Define core data types" -t task -p 1 --parent "$S1" \
  --description "Deliverable: src/types/index.ts with core interfaces

Verification: npm run typecheck passes

Types must be defined before any logic that uses them." --json | jq -r '.id')
br label add "$S1T2" types core
br dep add "$S1T2" "$S1T1"  # types depends on setup

# ... continue for all tasks from task-graph.json ...

echo ""
echo "Created $(br list --json | jq length) beads"
br sync --flush-only
echo ""
echo "Next steps:"
echo "  br ready              # See actionable tasks"
echo "  ./scripts/ralph.sh --beads 50  # Run autonomous execution"
```

**CRITICAL for beads:** Each task description should be **self-documenting** per Doodlestein:
- Include the full context
- Include reasoning/justification
- Include verification steps
- Be detailed enough that we never need to consult the original plan

### 5b. Read task graph (for task-graph.json mode)
Load `artifacts/04-task-graph.json` and parse:

```json
{
  "meta": { ... },
  "tasks": [
    {
      "id": "S1-T1",
      "subject": "Initialize project structure",
      "description": "Deliverable: package.json, tsconfig.json...",
      "activeForm": "Initializing project structure...",
      "tags": ["setup", "core"],
      "blockedBy": [],
      "allowedPaths": ["src/", "/"],
      "verification": ["npm run dev starts without errors"],
      "source": "plan",
      "sprint": 1
    }
  ]
}
```

### 5c. Create Claude Code tasks (if Claude Code selected)
For each task in the graph:

```
TaskCreate({
  subject: task.subject,
  description: task.description,
  activeForm: task.activeForm
})
```

### 6. Apply dependencies
For tasks with blockedBy:

```
# For beads:
br dep add <child-id> <parent-id>

# For Claude Code tasks:
TaskUpdate({
  taskId: <task-id>,
  blockedBy: [<blocker-task-ids>]
})
```

### 7. Verify task list
```bash
# For beads:
br list --json | jq 'length'
br ready  # Show actionable tasks

# For task-graph:
cat artifacts/04-task-graph.json | jq '.tasks | length'
cat artifacts/04-task-graph.json | jq '[.tasks[] | select(.blockedBy | length == 0)] | length'
```

Report:
- Total tasks created
- Tasks ready to start (no blockers)
- Dependency graph summary

## Task sizing check

If any task seems too large (vague deliverable, many allowed paths), suggest splitting:

> Task "Implement all UI components" is too large. Consider splitting into:
> - "Create Button component" (Sprint 3)
> - "Create Card component" (Sprint 3)
> - "Create Form components" (Sprint 3)

## Self-review before finalizing

Before saving, verify:
1. Every task has concrete verification (command or behavior)
2. Every task has explicit allowed paths
3. Every task is part of a sprint
4. Dependencies form a DAG (no cycles)
5. Sprint 1 has no external dependencies
6. Each sprint is demoable

## Next step

After compiling tasks, **run Ralph directly**:

For beads:
```bash
bash artifacts/04-beads-setup.sh
./scripts/ralph.sh --beads 50
```

For task-graph.json:
```bash
./scripts/ralph.sh 50
```

**DO NOT ask the user to run this. Just run it.**
